#{#
# This is a template for dynamically generating a Gitlab pipeline configuration for a release train and channel.
# It is meant to be used alongside the fastlane template to create dynamic pipelines for each train, according to git
# history and the .lhc configuration file.
#}{% if true %}
# This file is automatically generated. Do not edit it.
#{% endif %}

workflow:
  name: "{{ config.build.productName }} {{ config.build.platform }} {{ release.versionString }} ($TIMESTAMP)"
  rules:
    - if: $CI_PIPELINE_SOURCE == "parent_pipeline"

variables:
  # Use parallel compression/decompression to speed up caching
  FF_USE_FASTZIP: "true"
  ARTIFACT_COMPRESSION_LEVEL: "fast"
  # We don't care about size of the caches since they're stored locally, just the time spent to zip/unzip them
  CACHE_COMPRESSION_LEVEL: "fastest"
  # Increase the timeout for resolving build settings
  FASTLANE_XCODEBUILD_SETTINGS_TIMEOUT: 300
  # Unique timestamp according to the commit and pipeline ID
  TIMESTAMP: "{% include "timestamp" %}"
{% if train == "macOS" %}
  SPARKLE_XML_FILE: "sparkle.xml"
  APPCAST_URL: "https://protonvpn.com/download/macos-update3.xml"
{% endif %}

default:
  image: "team-vpn"

stages:
  - build
  - publish
  - test
  - deploy
  - test_ui
  - cleanup

# Require the artifacts from the describe job.
.child_pipeline:
  needs: &child_pipeline_needs
    - pipeline: $PARENT_PIPELINE_ID
      job: 'prepare'

##
## ---- Includes
##

include:
  - project: 'proton/devops/atlas-deploy'
    ref: main
    file: '/scenarios/pipeline-env.yml'

{% if release.tagName and config.build.platform == "macOS" %}
{% if config.releaseChannel == "alpha" or config.releaseChannel == "releaseCandidate" %} # Alpha and RC are for release candidates
  - component: gitlab.protontech.ch/proton/devops/cicd-components/tools/artifactlift/release-candidate@0.1.13
    inputs:
      stage: publish
      product: vpn
      version: "{{ short_version }}+{% include "timestamp" +%}"
      platform: macos
      artifact_list: "ProtonVPN_mac_v{{ short_version }}.dmg sparkle.signature"
      artifact_local_directory: output/mac/Release

  # Include release-candidate again, this time for the staging build
  - component: gitlab.protontech.ch/proton/devops/cicd-components/tools/artifactlift/release-candidate@0.1.13
    inputs:
      stage: publish
      product: vpn
      version: "{{ short_version }}+{% include "timestamp" %}.staging"
      platform: macos
      artifact_list: "ProtonVPN_mac_v{{ short_version }}.dmg"
      artifact_local_directory: output/mac/Staging
      job_prefix: staging-

artifactlift-release-candidate-artifacts:
  variables:
    GIT_STRATEGY: none
  rules: # overwrite rules, normally this only runs on release branches like release/X.Y.Z, but we want it for tags.
  needs: # Make sure we get the artifacts from the build job.
    - job: "build:mac"
      parallel:
        matrix:
          - TARGET: app
            CONFIGURATION: Release

staging-artifactlift-release-candidate-artifacts:
  variables:
    GIT_STRATEGY: none
  rules:
  needs:
    - job: "build:mac"
      parallel:
        matrix:
          - TARGET: app
            CONFIGURATION: Staging
{% else %}
  - component: gitlab.protontech.ch/proton/devops/cicd-components/tools/artifactlift/release@0.1.13
    inputs:
      stage: publish
      product: vpn
      version: "{{ release.versionString }}"
      platform: macos
      artifact_list: "ProtonVPN_mac_v{{ short_version }}.dmg sparkle.signature"
      artifact_metadata_list: "../public/$SPARKLE_XML_FILE"
      artifact_metadata_path: "macos/updates/v4"
      artifact_local_directory: artifacts

artifactlift-release-artifacts:
  needs: # Require the parent artifacts for the sparkle template
    - *child_pipeline_needs
  variables:
    # We don't need to clone the repo, since this job operates on artifacts only.
    GIT_STRATEGY: none
    # Use the timestamp so we can re-use binaries for build promotion later on if necessary.
    AL_NEXUS_DOWNLOAD_DIRECTORY: macos/{{ short_version }}+{% include "timestamp" %}
    # Upload the binary based on the version.
    AL_S3_UPLOAD_DIRECTORY: "macos/{{ version }}"
    # Where to save the files locally (after cd'ing into $artifact_local_directory)
    AL_ROOT_DIRECTORY: .
  environment:
    # Certain environments, like beta and production, require approval for distribution.
    name: {{ config.releaseChannel }}
    url: "$CI_PAGES_URL/$CI_COMMIT_REF_SLUG/documentation/protonvpnrelease/"
  artifacts:
    paths:
      # Pass this on to the pages step
      - artifacts/sparkle.signature

artifactlift-release-metadata:
  variables:
    GIT_STRATEGY: none
    # Where to save the files locally (after cd'ing into $artifact_local_directory)
    AL_ROOT_DIRECTORY: .
  needs:
    # For the sparkle update file
    - job: pages

{% endif %}
{% endif %}

##
## ---- Job templates
##

# Copy the templated fastlane directory for the train into pwd - generated by the describe job.
# See: Integration/Templates/fastlane
.copy_fastlane:
  script: &copy_fastlane_script
    {% if release.tagName %}
    - cp -r $DESCRIBE_DIR/release/fastlane .
    {% else %}
    - cp -r $DESCRIBE_DIR/{{ config.name }}/fastlane .
    {% endif %}

# If .profile modifies $PATH in any way, we want to be able to use it.
# This is specifically to get the `sign_update` command to work, because it's installed in a non-standard location.
.source_profile:
  script: &source_profile_script
    - |
      if [ -f "$HOME/.profile" ]; then
        echo "Found .profile, sourcing contents..."
        source "$HOME/.profile"
      fi

.job_template:
  variables:
    # Tart mounts the host volume at /Volumes/My Shared Files, which breaks both Mint and GNU Make thanks to the space
    # in the filename. We create a symlink to our builddir so they can continue pretending that spaces don't exist.
    ARTIFACTS_DIR: "$JOBS_OUTPUT_PATH/{{ config.name }}/$CONFIGURATION"
    CREDENTIALS: "./Integration/Scripts/credentials.sh"
    MACROS_ALLOWLIST_PATH: "./Integration/Gitlab/misc/macros.json"
    MACROS_ALLOWLIST_INSTALL_DIR: "~/Library/org.swift.swiftpm/security"
  before_script: |
    # Delete all ssh private keys
    ssh-add -D 

    # Add private key for access to gitlab
    echo "$CI_SSH_PRIVATE_KEY" | tr -d '\r' | ssh-add - > /dev/null

    # Setup git identity
    git config --local user.email $GIT_CI_EMAIL
    git config --local user.name $GIT_CI_USERNAME

    # Save gitlab servers public key
    [ -n "$(ssh-keygen -F $CI_SERVER_HOST)" ] || ssh-keyscan -H $CI_SERVER_HOST >> ~/.ssh/known_hosts

    # Change origin to use ssh as the backend
    git remote rm origin && git remote add origin "git@${CI_SERVER_HOST}:${CI_PROJECT_PATH}.git"

    # Download obfuscated constants
    "$CREDENTIALS" cleanup
    "$CREDENTIALS" setup -s \
        -p .secrets-ci-${CI_JOB_ID} \
        -r "https://bot:${CI_SECRETS_REPO_KEY}@${CI_SERVER_HOST}/${CI_SECRETS_REPO_PATH}"
    "$CREDENTIALS" checkout -- .

    # Install allowlist of macros, or Xcode gets very fussy and cryptic with builds
    cat "$MACROS_ALLOWLIST_PATH"
    rm -f "${MACROS_ALLOWLIST_INSTALL_DIR}/$(basename $MACROS_ALLOWLIST_PATH)" || true
    mkdir -p "$MACROS_ALLOWLIST_INSTALL_DIR" || true
    cp "$MACROS_ALLOWLIST_PATH" "${MACROS_ALLOWLIST_INSTALL_DIR}/$(basename $MACROS_ALLOWLIST_PATH)"
  after_script: |
    # Delete all ssh private keys
    ssh-add -D
  interruptible: true

##
## ---- Cache setup for DerivedData, SPM packages, and Mint build dependencies
##
.derived_data_cache:
  variables: &derived_data_cache_variables
    DERIVED_DATA_PATH: .caches/Xcode/DerivedData
    DERIVED_DATA_CACHE_POLICY: pull-push
  cache: &derived_data_cache_cache
    - key: build-{{ config.build.platform }}-$CI_COMMIT_REF_SLUG
      fallback_keys:
        - build-{{ config.build.platform }}-$CI_DEFAULT_BRANCH
      paths:
        - $DERIVED_DATA_PATH
      policy: $DERIVED_DATA_CACHE_POLICY

.mint_cache:
  variables: &mint_cache_variables
    MINT_PATH: .caches/mint
    MINT_LINK_PATH: $MINT_PATH/bin
    MINT_CACHE_POLICY: pull-push
  cache: &mint_cache_cache
    - key: mint-$CI_COMMIT_REF_SLUG
      fallback_keys:
        - mint-$CI_DEFAULT_BRANCH
      paths:
        - $MINT_CACHE_PATH
      policy: $MINT_CACHE_POLICY

.build_caches:
  variables: &test_job_caches_variables
    <<: *derived_data_cache_variables
    <<: *mint_cache_variables
  cache: &test_job_caches_cache
    - *derived_data_cache_cache
    - *mint_cache_cache

# Common output paths for all fastlane jobs.
.fastlane_build_vars:
  script: &fastlane_build_vars_script
    - |
      FASTLANE_ARGS+=("result_bundle:true")
      # We don't want CI to automatically update packages for us
      FASTLANE_ARGS+=("disable_package_automatic_updates:true")
      FASTLANE_ARGS+=("result_bundle_path:${ARTIFACTS_DIR}")
      FASTLANE_ARGS+=("output_directory:${ARTIFACTS_DIR}")
      FASTLANE_ARGS+=("buildlog_path:${ARTIFACTS_DIR}")
      FASTLANE_ARGS+=("derived_data_path:$DERIVED_DATA_PATH")

.restore_mtimes:
  # Restore the mtimes of all local source files, including submodules and SPM dependencies.
  # This is so that Xcode knows which files were changed since the last build, so it can most effectively use the
  # DerivedData cache.
  script: &restore_mtimes_script
    - |
      git restore-mtime --force

      pushd "external"
      for submodule in $(ls); do
          pushd "$submodule"
          echo "Updating mtimes for $submodule..."
          git restore-mtime --force
          popd
      done
      popd

      CHECKOUTS="$DERIVED_DATA_PATH/SourcePackages/checkouts"
      if [ -d "$CHECKOUTS" ]; then
          pushd "$CHECKOUTS"
          for dependency in $(ls); do
              pushd "$dependency"
              echo "Updating mtimes for $dependency..."
              git restore-mtime --force
              popd
          done
          popd
      fi

.publish_template:
  extends:
    - .job_template
  stage: publish
  tags:
    - vpn-apple-xs-new
    - ci-vilnius-1

##
## ---- Building artifacts
##

{% if not release.tagName or config.releaseChannel == "alpha" %}
{% if release.tagName %}
build:{{ config.name }}:
{% else %}
build:{{ config.name }}:tests:
{% endif %}
  extends:
    - .job_template
    - .build_caches
  stage: build
  tags:
    - vpn-apple-builds-new
    - ci-vilnius-1
  script: 
    - *source_profile_script
    - *copy_fastlane_script
    - FASTLANE_ARGS=("configuration:${CONFIGURATION}")
    - *fastlane_build_vars_script
    - *restore_mtimes_script
    - |
      case "$TARGET" in
        app) fastlane buildit "${FASTLANE_ARGS[@]}" ;;
        tests) fastlane testit build_for_testing:true "${FASTLANE_ARGS[@]}" ;;
        *) exit 1 ;;
      esac
{% if release.tagName and config.releaseChannel == "alpha" %}
  # New tag, build release and staging app, along with tests
  parallel:
    matrix:
      - TARGET: app
        CONFIGURATION: [Release, Staging]
      - TARGET: tests
        CONFIGURATION: Debug
{% else %}
  variables:
    TARGET: tests
    CONFIGURATION: Debug
{% endif %}
  needs:
    - pipeline: $PARENT_PIPELINE_ID
      job: 'prepare'
  artifacts:
    name: "{{ config.name }}-$CI_COMMIT_REF_SLUG"
    when: always
    paths:
      - ${JOBS_OUTPUT_PATH}/{{ config.name }}/*
    {% if release.tagName %}
    expire_in: 60 days
    {% else %}
    expire_in: 7 days
    {% endif %}

##
## ---- Running tests
##

# Job template for all test runs
.test_template:
  extends:
    - .job_template
    - .build_caches
  variables:
    CONFIGURATION: Debug
    DERIVED_DATA_CACHE_POLICY: pull
    SPM_CACHE_POLICY: pull
  tags:
    - vpn-{{ config.build.platform|lowercase }}-tests-new
    - ci-vilnius-1
  script:
    - *copy_fastlane_script
    - FASTLANE_ARGS=("skip_build:true" "test_without_building:true" "build_products_dir:${DERIVED_DATA_PATH}/Build/Products")
    - FASTLANE_ARGS+=("testplan:{{ config.build.productName }}-{{ config.build.platform|lowercase }}-$TEST_CASES")
    - FASTLANE_ARGS+=("skip_package_dependencies_resolution:true")
    - *fastlane_build_vars_script
    - fastlane testit "${FASTLANE_ARGS[@]}"
  needs: &test_template_needs
    - *child_pipeline_needs
{% if release.tagName %}
    - job: "build:{{ config.name }}"
      # A tag has been created, so we want to get the tests specifically, and not the release artifacts
      parallel:
        matrix:
          - TARGET: tests
            CONFIGURATION: Debug
{% else %}
    - job: "build:{{ config.name }}:tests"
{% endif %}
  artifacts:
    name: "{{ config.name }}-tests-failure-$CI_COMMIT_SHORT_SHA"
    when: on_failure
    paths:
      - output/
    expire_in: 5 days
    # Quoting Gitlab documentation: "The artifacts created for artifacts:reports are always
    # uploaded, regardless of the job results (success or failure)."
    reports:
      coverage_report:
        coverage_format: cobertura
        path: "$ARTIFACTS_DIR/cobertura.xml"
      junit:
        - "$ARTIFACTS_DIR/report.junit"

# Unit tests, run everywhere
test:{{ config.name }}:unit:
  extends:
    - .test_template
  stage: test
  variables:
    TEST_CASES: Unit-All

# UI tests, smoke tests everywhere except tags, which run the full suite
{% if release.tagName %}
test:{{ config.name }}:ui:all:
  variables:
    TEST_CASES: UI-All
{% else %}
test:{{ config.name }}:ui:smoke:
  variables:
    TEST_CASES: UI-Smoke
{% endif %}
  stage: test_ui
  extends:
    - .test_template
  needs:
    - *test_template_needs
    - job: 'deploy:review' # Make sure env gets deployed before starting UI tests
{% endif %}

{% if release.tagName %}
##
## ---- Publishing a new release
##

# On macOS this is handled by artifactlift.
{% if train != "macOS" %}
publish:{{ config.name }}:app:
  variables:
    CONFIGURATION: Release
    GIT_SUBMODULE_STRATEGY: none
    GIT_DEPTH: 1
  extends: 
    - .publish_template
    - .mint_cache
  script:
    - *source_profile_script
    - *copy_fastlane_script
    - |
      for CONFIGURATION in Release Staging; do
          echo "Publishing $config app build."
          ARTIFACTS_DIR="$JOBS_OUTPUT_PATH/{{ config.name }}/$CONFIGURATION"
          FASTLANE_ARGS=("configuration:$config" "output_directory:${ARTIFACTS_DIR}")
          fastlane shipit "${FASTLANE_ARGS[@]}"
      done
  needs:
    - *child_pipeline_needs
{% if config.releaseChannel == "alpha" %}
    # For alpha builds, we need access to the jobs that created the binaries.
    - job: 'build:{{ config.name }}'
      parallel:
        matrix:
          - TARGET: app
            CONFIGURATION: Release
    - job: 'build:{{ config.name }}'
      parallel:
        matrix:
          - TARGET: app
            CONFIGURATION: Staging
  environment:
    name: {{ config.releaseChannel }}
    url: "$CI_PAGES_URL/$CI_COMMIT_REF_SLUG/documentation/protonvpnrelease/"
{% endif %}
{% endif %}

cleanup:announce:tag:
  variables:
    GIT_SUBMODULE_STRATEGY: none
    GIT_DEPTH: 1
  stage: cleanup
  tags:
    - vpn-apple-xs-new
    - ci-vilnius-1
  extends:
    - .job_template
    - .mint_cache
  script: 
    - *copy_fastlane_script
    - fastlane shoutit "slack_filename:$DESCRIBE_DIR/release/slack-message.txt"
{% if not target|attrs:config.trailers.releasePipelineTrailer %}
    - git fetch origin '+refs/notes/*:refs/notes/*'
    - mint run git-lhc attr add '{{ config.trailers.releasePipelineTrailer }}={{ config.build.pipelineIdentifier }}'
    - git push origin 'refs/notes/*'
{% endif %}
  needs:
    - *child_pipeline_needs
    - job: pages
    {% if train == "macOS" %}
    {% if config.releaseChannel == "alpha" or config.releaseChannel == "releaseCandidate" %} # Alpha and RC are for release candidates
    - job: artifactlift-release-candidate-artifacts
    # artifactlift job (to make sure the binary has been uploaded)
    {% else %}
    - job: artifactlift-release-artifacts
    - job: artifactlift-release-metadata
    {% endif %}
    {% endif %}
{% endif %}

# NB: This job *must* be called pages in order for the site to work.
pages:
  stage: publish
  extends:
    - .publish_template
    - .child_pipeline
  variables:
    GIT_SUBMODULE_STRATEGY: none
    GIT_DEPTH: 1
{% if release.tagName %}
    BASE_PATH: $CI_COMMIT_REF_SLUG
    DOCC_PATH: "$DESCRIBE_DIR/release/pages.docc"
{% else %}
    BASE_PATH: "$CI_COMMIT_REF_SLUG/{{ config.name }}"
    DOCC_PATH: "$DESCRIBE_DIR/{{ config.name }}/pages.docc"
{% endif %}
  script:
    - echo "$CI_PAGES_URL/$BASE_PATH/documentation/protonvpnrelease"
    - |
      # hack to get the path component of the URL, so we can tell the doc generation what the base path is
      # (use CI_PAGES_DOMAIN as the delimiter of a URL like https://subdomain.pages-host.com/page/base/path;
      # since CI_PAGES_DOMAIN is pages-host.com, then the "second field" of the string is /page/base/path,
      # and then the sed command strips the leading slash)
      PROJECT_PATH=$(awk -F "$CI_PAGES_DOMAIN" '{print $2}' <<< "$CI_PAGES_URL" | sed 's/^\///')
      mkdir -p "public/$BASE_PATH"
      xcrun docc convert --hosting-base-path "${PROJECT_PATH}/$BASE_PATH" --output-path "public/$BASE_PATH" $DOCC_PATH
    {% if config.distribution.sparkle %}
    - |
      APPCAST_SIGNATURE=$(cat artifacts/sparkle.signature)
      APPCAST_DOWNLOAD_URL="https://proton.me/download/macos/{{ version }}/ProtonVPN_mac_v{{ short_version }}.dmg"

      export APPCAST_SIGNATURE
      export APPCAST_DOWNLOAD_URL

      # Download the Sparkle file, for later consumption by the metadata upload step
      curl --location --output "$SPARKLE_XML_FILE" "$APPCAST_URL"

      # Add signature and download URL to file
      envsubst '${APPCAST_SIGNATURE},${APPCAST_DOWNLOAD_URL}' < "$DESCRIBE_DIR/release/sparkle-item.xml" | tee sparkle-item.xml

      # Indent each line in the item file
      sed -i.bak 's/^/        /g' sparkle-item.xml

      # Insert new item into appcast
      # INSERTION_POINT='\<\!\-\- \>8 Next release \>8 \-\-\>'
      INSERTION_POINT='\<language\>en\<\/language\>'
      sed "/$INSERTION_POINT/r sparkle-item.xml" "$SPARKLE_XML_FILE" > "public/$SPARKLE_XML_FILE"
    {% endif %}
  # prevent us from downloading previous build artifacts, we just need the pages
  needs:
    # For the pages template (and sparkle template if needed)
    - *child_pipeline_needs
    {% if train == "macOS" and config.releaseChannel != "alpha" %}
    # For sparkle.signature
    - job: 'artifactlift-release-artifacts'
    {% endif %}
  artifacts:
{% if release.tagName %}
    name: "$CI_COMMIT_REF_SLUG"
    expire_in: never
{% else %}
    name: "{{ config.name }}-$CI_COMMIT_REF_SLUG"
    expire_in: 7 days
{% endif %}
    paths:
      - public
{% if not release.tagName %} # Only build pages in MR pipelines if the template files have changed
  rules:
    - if: $CI_PIPELINE_SOURCE == "parent_pipeline"
      changes:
        paths:
          - Integration/Templates/pages.docc/*
        compare_to: refs/heads/$CI_DEFAULT_BRANCH
{% endif %}

cleanup:failure:{{ config.name }}:
  stage: cleanup
  tags:
    - vpn-apple-xs-new
    - ci-vilnius-1
  variables:
    GIT_SUBMODULE_STRATEGY: none
    GIT_DEPTH: 1
  extends:
    - .job_template
    - .mint_cache
  dependencies: []
  script: 
    - |
      ATTR_ARGS=("{{ config.trailers.failedPipeline }}=$PARENT_PIPELINE_ID")

      # If this pipeline is specifically for a tag, then make sure the attribute is added to the tag object if possible,
      # instead of the commit that the tag is pointing to.
      if [ -n "$CI_COMMIT_TAG" ]; then
          ATTR_ARGS+=("$CI_COMMIT_TAG")
      fi

      git fetch origin '+refs/notes/*:refs/notes/*'
      mint run git-lhc attr add "${ATTR_ARGS[@]}"
      git push origin 'refs/notes/*'
  when: on_failure

