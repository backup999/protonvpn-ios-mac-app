{% extends "Fastfile.base" %}

{% block header %}
# !begin: ProtonVPN header
# Helperfile contains private lanes for setting plist keys and creating app dmgs
import("./Helperfile")
# !end: ProtonVPN header
{{ block.super }}
{% endblock %}

##
## ---- Build Options
##

{% block options %}
{{ block.super }}
    # !begin: ProtonVPN options
    :slack_channel => "#vpn-apple-builds",
    :slack_filename => "",
    :build_number => $timestamp,
    {% if config.build.ci %}
    :version_number => "{{ short_version }}",
    {% else %}
    :version_number => "{{ version }}",
    {% endif %}
    {% if train == "macOS" %}
    :dmg_config => "Integration/Scripts/dmg_config.py",
    :dmg_output_name => "{{ config.build.productName }}_mac_v{{ short_version }}",
    {% elif train == "iOS" %}
    :changelog => <<~CHANGELOG ,
{{ release.body|indent:4," ",true }}
    CHANGELOG
    {% if config.distribution.appStore.testFlightGroup %}
    :testflight_groups => ["{{ config.distribution.appStore.testFlightGroup }}"],
    {% endif %}
    {% endif %}
    # !end: ProtonVPN options
{% endblock %}

{% block secrets %}
{{ block.super }}
    # !begin: ProtonVPN secrets
    :atlas_secret => ENV["ATLAS_SECRET"],
    # !end: ProtonVPN secrets
{% endblock %}

{% block initialize %}
    {{ block.super }}
    # !begin: ProtonVPN initialize
    # Configuration is one of the only values that is always passed over the command line. This is because pipeline
    # configs are generated once per train, and we wouldn't want to start more than one pipeline per train to avoid
    # causing too much congestion.
    {% if train == "iOS" %}
    if $options[:configuration] == "Staging"
        $app_identifier += ".debug"
    end
    {% endif %}
    if $options[:configuration] == "Staging" || $options[:configuration] == "Release"
        {% if config.build.platform == "iOS" or config.build.platform == "tvOS" %}
        $options[:export_method] = "app-store"
        $options[:code_sign_identity] = "Apple Distribution"
        {% elif config.build.platform == "macOS" %}
        $options[:export_method] = "developer-id"
        $options[:notarize] = true
        {% endif %}
    else
        $options[:export_method] = "development"
    end
    {%- if train == "macOS" %}
    # Notarize the dmg, which automatically encompasses the app itself.
    $options[:notarize_package] = "#{$options[:output_directory]}/{{ config.build.productName }}_mac_v{{ short_version }}.dmg"
    {%- endif %}
    # !end: ProtonVPN initialize
{% endblock %}

##
## ---- Product Targets
##

{% block targets +%}
    # !begin: ProtonVPN targets
    {% if config.build.platform == "iOS" %}
    $app_identifier => "ProtonVPN",
    "#{$app_identifier}.OpenVPN-Extension" => "OpenVPN Extension",
    "#{$app_identifier}.WireGuardiOS-Extension" => "WireGuardiOS Extension",
    "#{$app_identifier}.widget" => "Quick Connect Widget",
    "#{$app_identifier}.Siri-Shortcut-Handler" => "Siri Shortcut Handler",
    {% elif config.build.platform == "macOS" %}
    $app_identifier => "ProtonVPN-mac",
    "ch.protonvpn.ProtonVPNStarter" => "ProtonVPNStarter",
    "#{$app_identifier}.OpenVPN-Extension" => "ProtonVPN OpenVPN",
    "#{$app_identifier}.WireGuard-Extension" => "ProtonVPN WireGuard",
    {% elif config.build.platform == "tvOS" %}
    $app_identifier => "ProtonVPN-tvOS",
    "#{$app_identifier}.WireGuard-tvOS" => "WireGuard-tvOS",
    {% endif %}
    # !end: ProtonVPN targets
{% endblock %}

{% block test_targets +%}
    # !begin: ProtonVPN test_targets
    {% if config.build.platform == "iOS" %}
    "prt.ProtonVPNUITests" => "ProtonVPNTests",
    "#{$app_identifier}.ProtonVPNUITests" => "ProtonVPNUITests",
    {% elif config.build.platform == "macOS" %}
    "ch.protonvpn.ProtonVPNTests" => "ProtonVPNmacOSTests",
    "ch.protonmail.vpn.ProtonVPNUITests" => "ProtonVPNmacOSUITests",
    {% elif config["platform"] == "tvos" %}
    "#{$app_identifier}.tvOS.test.unit" => "ProtonVPNtvOSTests",
    "#{$app_identifier}.tvOS.test.ui" => "ProtonVPNtvOSUITests",
    {% endif %}
    # !end: ProtonVPN test_targets
{% endblock %}

##
## ---- Build Setup (*not* test builds)
##

{% block prebuild %}
{{ block.super }}
    # !begin: ProtonVPN prebuild
    unless $options[:configuration] == "Release" or not $options[:atlas_secret]
        set_plist_keys(
            xcodeproj: $options[:xcodeproj],
            scheme: $options[:scheme],
            configuration: $options[:configuration],
            extra_plist_entries: {
                "ProtonVPNAtlasSecret" => $options[:atlas_secret],
            },
        )
    end
    # !end: ProtonVPN prebuild
{% endblock %}

{% block postbuild %}
    {% if train == "macOS" %}
    # Note: this is what is getting notarized, instead of the app
    create_dmg()
    {% endif %}

    # Build notarization
    {{ block.super }}

    {% if train == "macOS" %}
    # Sparkle signature goes here instead of in shipit step - signature is uploaded as part of binary promotion
    # Note: this should happen after notarization, since stapling the ticket to the dmg alters it (and thus the hash)
    $options[:sparkle_binary_path] = File.expand_path("#{$repo_path}/#{$options[:output_directory]}/#{$options[:dmg_output_name]}.dmg")
    binary_path = rel_to_repo(get_or_die($options, :sparkle_binary_path))
    ed_key = get_or_die($secrets, :appcast_ed_key)
    output_directory = rel_to_repo(get_or_die($options, :output_directory))

    hash = Digest::SHA256.hexdigest(File.read(binary_path))
    signature = `echo #{ed_key} | sign_update -f - #{binary_path}`.strip
    die "Could not sign binary: #{signature}" unless $?.success?

    signature << " hash=\"#{hash}\""
    File.open("#{output_directory}/sparkle.signature", 'w') { |file|
        file.write(signature)
    }
    {% endif %}
{% endblock %}

##
## ---- Test Setup (including test builds)
##

{% block pretest +%}
    # !begin: ProtonVPN pretest
    # {{ train }}
    unless not $options[:atlas_secret]
        plist_entries = {
            "ProtonVPNAtlasSecret" => $options[:atlas_secret],
        }

        set_plist_keys(
            xcodeproj: $options[:xcodeproj],
            scheme: $options[:scheme],
            configuration: $options[:configuration],
            extra_plist_entries: plist_entries,
            extra_test_plist_entries: plist_entries,
        )
    end

    {% if train == "iOS" or train == "tvOS" %}
    $options[:create_simulator] = true

    {% if config.build.ci %}
    $options[:destination_name] = "{{ config.build.productName }}-{{ config.build.platform|lowercase }}-{{ config.build.pipelineIdentifier }}"
    {% else %}
    $options[:destination_name] = "{{ config.build.productName }}-{{ config.build.platform|lowercase }}"
    {% endif %}

    {% if train == "iOS" %}
    # We don't pass this to run_tests, it's just for finding the .xctestrun file.
    # (Weird things happen if you decide to pass this value to run_tests. I don't recommend it.)
    $options[:sdk] = "iphonesimulator17"
    $options[:simulator_device_type] = "iPhone-12"
    {% else %}
    $options[:sdk] = "appletvsimulator17"
    $options[:simulator_device_type] = "Apple-TV-4K-3rd-generation-1080p"
    {% endif %}

    {% elif train == "macOS" %}
    $options[:sdk] = "macosx14"
    $options[:destination_arch] = `uname -m`.strip
    {% endif %}
    # !end: ProtonVPN pretest
{{ block.super }}
{% endblock %}

##
## ---- Test Teardown
##
{% block posttest +%}
    # !begin: ProtonVPN posttest
    if (testplan = $options[:testplan]) and (tests = tests_in_testplan("#{$repo_path}/{{ config.build.testplansDirectory }}/#{testplan}.xctestplan"))
        $options[:coverage_exclude_targets] = tests
    end

    unless $options[:build_for_testing]
        interpret_code_coverage()
    end
    # !end: ProtonVPN posttest
{{ block.super }}

{% endblock %}

##
## ---- Shipping setup
##

# Note: macOS uploads its binary in a separate step after we create the sparkle file, we won't know whether it's
# uploaded until we get the callback for the release announcement.
{% block preship +%}
    # !begin: ProtonVPN preship
    {% if train == "iOS" or train == "tvOS" %}
    $options[:ipa] = File.expand_path("#{$repo_path}/#{$options[:output_directory]}/#{$options[:output_name]}.ipa")
    {% endif %}
    # !end: ProtonVPN preship
{{ block.super }}
{% endblock %}

{% block deliver_args %}
    # !begin: ProtonVPN deliver
    app_version: $options[:version_number],
    build_number: $options[:build_number],
    # !end: ProtonVPN deliver
{% endblock %}

{% block sparkle %}
    # Instead of doing sparkle during the shipit step, we generate the signature during the buildit step for
    # more straightforward binary promotion. The artifactlift code provided by the devops team is tightly coupled
    # as of this writing and doesn't allow for shipit to run between the binary upload and the metadata upload pipeline
    # steps. See the artifactlift-release-metadata section of the gitlab pipeline template for more information.
{% endblock %}

{# Commented out for now.
{% block slack_args %}
{{ block.super }}
use_webhook_configured_username_and_icon: true,
{% endblock %}
#}
